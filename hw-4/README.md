# Вокруг PHP – экосистема веб-приложений. Обучение в записи
## Продвинутое unit-тестирование
### Домашнее задание

<br><br>
1. Сделайте новую ветку из той, которую мы создали на прошлом уроке. Это нужно для того, чтобы мы могли работать с кодом из прошлого урока.<br><br>
2. Загрузите весь код из сегодняшнего урока в Git в новую ветку, создайте новый pull request. Пришлите на проверку ссылку на pull request.<br><br>
3. ⚹ Создайте тесты на оставшийся класс TgEvents. Обратите внимание, что тут придется работать как с исходящими, так и с входящими зависимостями. Вам придется иметь дело как с Mock, так и с Stub.<br><br>

### Решение задания
#### Задание 1. Разбор ТЗ с тимлидом

На прошлом занятии мы определили много контрактов нашего кода, на которые мы
хотим писать unit-тесты. <br>
На часть из них мы уже написали тесты, сегодня нам нужно написать тесты на
оставшуюся часть, используя новый функционал тестовых двойников и
рефакторинг. <br>
Применим новые знания и определим, что нам нужно сделать, чтобы написать все
тесты, которые мы хотим. <br>

#### Задание 2. Рефакторинг кода

Целью рефакторинга для нас будет являться оптимизация структуры кода таким образом, чтобы мы могли без проблем создать unit-тесты. <br>
Для этого мы проработаем пункт лекции “Антипаттерны проектирования”. Наша задача — классы команд сделать, по сути, фабриками или контроллерами. <br>
В них не будет производиться никакой логики, только – создание экземпляров классов и передача управления. <br>
Это поможет вынести получение знаний в конструктор новых классов, после чего их будет просто тестировать, передавая в конструктор тестовых двойников. <br>
Исходя из новых классов контракты, которые мы хотим тестировать немного меняются. <br>
Более того, благодаря грамотному рефакторингу и тому, что наши классы теперь следуют
принципу SOLID, нам необязательно открывать для изменения приватные методы. <br>
Мы можем тестировать класс целиком, вызывая только один его метод, при этом тестируя
различные сценарии. <br>
Еще раз посмотрим на классы и определим, какие сценарии мы будем тестировать.
#### Задание 3. Создаем тесты, используя тестовых двойников
Начинаем писать тесты по заданным сценариям, кроме TgEventsTest, он остается для домашнего задания из-за большого объема работы.
#### Задание 4. Работа с тестовым API
Начинаем создавать тестовый API. Ваша первоочередная задача – вынести все DataProvider в отдельные классы.
#### Задание 5. Создаем отчет о покрытии кода тестами и о мутационном тестировании
Алгоритм действий: <br>
1. Устанавливаем Xdebug
2. Далее для всех классов тестов нужно определить, какие классы они покрывают
3. Не лишним будет удалить echo в EventSender, а так же создать phpunit.xml
4. Рекомендую также сразу поменять значение в phpunit.xml
5. Далее можно создать отчет
6. Не забыв при этом добавить директорию covers_html в .gitignore. Далее создаем отчет о мутационном тестировании Файл infection.json
7. Устанавливаем infection
8. Затем запускаем


<br><br><hr>

### Перечень вопросов, которые также могут задать:
1. Какие вы помните антипаттерны проектирования приложения, которые мешают написанию хороших unit тестов? <br>
 **Ответ:** К антипаттернам проектирования, которые мешают unit-тестированию, можно отнести следующие ситуации: 
- Сильная связанность (Tight Coupling), когда компоненты сильно зависят друг от друга, их трудно тестировать изолированно.
- Большие классы или методы, так как сложные и многофункциональные классы или методы труднее покрыть тестами.
- Использование глобальных состояний, так как глобальные переменные и состояния затрудняют предсказуемость тестов.
- Отсутствие интерфейсов и абстракций, потому что без абстракций сложно заменить зависимости на моки или стабы.
- Сложная логика в конструкторах, потому что логика в конструкторах усложняет создание объектов для тестирования.


2. Что такое чистая функция? Как вы считаете, должен ли unit-тест стремиться быть чистой функцией? Какие для этого есть инструменты? <br>
   **Ответ:** <br>
   Чистая функция - это функция, которая не имеет побочных эффектов и всегда возвращает один и тот же результат для одних и тех же входных данных. <br>
   Unit-тесты должны стремиться быть чистыми функциями, чтобы быть предсказуемыми и изолированными. <br>
   Для мокирования и изоляции тестируемого кода часто используют фреймворки (инструменты)такие, как Mockery и Prophecy для PHP или такие, как Mockito для Java и unittest.mock для Python.


3. В чем разница между Mock и stub? Какими бывают их подтипы и в чем между ними разница? <br>
   **Ответ:** Инструменты, такие как Mockery, позволяют создавать моки, стабы и шпионы для тестирования в PHP.
   Mock - имитация объекта, которая проверяет взаимодействие с тестируемым кодом, например, сколько раз был вызван метод. <br>
   Stub - простая заглушка, назначение которой, возвращать заранее определенные значения, не проверяя их взаимодействие. <br>
   Существуют подтипы: <br>
   Fake - более сложная имитация, которая может содержать логику. <br>
   Spy - реальный объект, который записывает взаимодействия для последующей проверки. <br>
   

4. Как мы можем создать отчет о покрытии кода тестами? <br>
   **Ответ:** Отчет о покрытии кода тестами возможен при использовании инструментов, таких как PHPUnit для PHP или таких, как JaCoCo для Java и coverage.py для Python, которые могут быть интегрированы с Xdebug для генерации отчетов о покрытии кода.


5. Что такое мутационное тестирование? Как мы можем создать отчет о мутационном тестировании? <br>
   **Ответ:** <br>
   Мутационное тестирование - это процесс изменения кода (мутаций) для проверки, обнаружат ли тесты эти изменения.
   Создать отчет о мутационном тестировании возможно с помощью инструментов, такие как Infection для PHP, или PIT для Java и mutmut для Python. С ними создают отчеты, показывающие, какие мутации были убиты тестами, а какие выжили, что указывает на недостатки и неточности программы кода в тестах.


<br><br><hr>
**В качестве решения приложить:** <br>
➔ ссылку на pull request в вашем репозитории с домашним заданием <br>
⚹ – дополнительное задание
